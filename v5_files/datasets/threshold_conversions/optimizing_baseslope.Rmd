 ---
title: "Optimizing Base-Slope"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(sf)
library(tidymodels)

filter_dates <- function(data, date_start, date_end) {
  if (!is.null(date_start)) {
    data <- filter(data, date >= as.Date(date_start))
  }
  if (!is.null(date_end)) {
    data <- filter(data, date <= as.Date(date_end))
  }
  data
}
```

## Data Setup

We read in the *C. Finmarchicus* dataset -- the merged ecomon/azmp dataset bound to Brickman environmental covariates. The ecomon dataset has been vertically corrected using Caroline's GAM and a region has been assigned to each datapoint (ESS, WSS, GoM, GSL)

```{r}
root <- "/mnt/ecocast/projectdata/calanusclimate/src"

ae <- readr::read_csv(file.path(root, "tc_datasets/ae_regionvd_cfin.csv.gz"),
                      col_types = readr::cols())
```

All estimates of individual dry weight are pulled from Sorochan et. al 2019. 

![Sorochan et. al 2019, Table 2](sorochan_table.jpeg)
Using Sorochan et. al 2019, we convert abundance to dry weight using region and filter the points to be within 1990-2015. 

```{r}
ae_dw <- ae |>
  mutate(dry_weight = abundance * 
         map(region_tc, ~ifelse(.x == "gsl", 333, 195)) |> unlist()) |>
  filter_dates("1990-01-01", "2015-12-31")

glimpse(ae_dw)
```

## Base/Slope Comparison Setup

We create a "dynamic biomass threshold" that varies with bathymetry. When bathymetric depth is less than 300m, the threshold is constant at a **base** value. When bathymetric depth is more than 300m, the threshold increases linearly with a **slope**.

We explore the AUC based on a boosted regression tree model tuned for the 10000 cfin/m2 flat threshold. 

```{r}
idw <- 264 # Averaged from Sorochan et. al

threshold_method <- function(Bathy_depth, base, slope) {
  map_dbl(Bathy_depth - 300, max, 0) * slope + base
}
```

```{r}
# Returns a recipe that
base_slope_recipe <- function(base, slope) {
  recipe(dry_weight ~ Bathy_depth + SST + SSS + Sbtm + Tbtm + MLD + U + V + month, 
         data = ae_dw) |>
    update_role(dry_weight, U, V, new_role = "ID") |>
    step_log(Bathy_depth, offset = 1, base = 10) |>
    step_mutate(patch = (dry_weight >= threshold_method(Bathy_depth, base, slope)) |>
                  as.numeric() |> as.factor(),
                role = "outcome") |>
    step_mutate(Vel = sqrt(U^2 + V^2), role = "predictor")
}
```

```{r} 
# defining the model name
tuned <- boost_tree() |>
  set_mode("classification") |>
  set_engine("xgboost") |>
  set_args(trees = 1000,
           tree_depth = 6,
           learn_rate = 0.0745,
           min_n = 26,
           mtry = 5,
           sample_size = .597,
           loss_reduction = 0.00568)

untuned <- boost_tree() |>
  set_mode("classification") |>
  set_engine("xgboost") |>
  set_args(trees = 100)
```

**How do we define the base-slope values to explore?**

Base - Let's explore values 30,000 to 40,000, with slope 10 to 1000

```{r}
# Creating a workflow set
base <- c(30000, 35000, 40000) * idw
slope <- c(0, 10, 100, 1000) * idw
baseslope <- expand.grid(base = base, slope = slope)

recipe_list <- baseslope |>
  apply(1, function(r) base_slope_recipe(r[1], r[2]))

model_list <- list(tuned = tuned, untuned = untuned)

bs_workflows <- workflow_set(recipe_list, model_list, 
                             cross = TRUE)
```

```{r eval = FALSE}
folds <- vfold_cv(ae_dw, v = 4, repeats = 1, strata = "dry_weight")

# resampling and collecting results
res_table <- bs_workflows |>
  workflow_map(
    fn = "fit_resamples", 
               verbose = TRUE, 
               seed = 400, 
               resamples = folds, 
               metrics =  metric_set(roc_auc, accuracy))
```

```{r eval = FALSE, echo = FALSE}
res_table <- res_table |> collect_metrics()

rec_model_nums <- res_table$wflow_id |>
  map_dfr(~unlist(strsplit(.x, '_'))[c(2, 5)] |>
            setNames(c("recipe", "model_type"))) |>
  mutate(across(model_type, ~ifelse(.x == 1, "tuned", "untuned")))

res_table <- rec_model_nums$recipe |>
  map_dfr(~baseslope[.x,]) |>
  bind_cols(rec_model_nums,
            res_table) |>
  select(base, slope, model_type, .metric, mean, std_err)

res_table |> readr::write_csv("wkfs_data.csv")
```

```{r echo = FALSE}
res_table <- readr::read_csv("wkfs_data.csv", col_types = readr::cols())

head(res_table)
```

```{r}
ggplot(res_table |> filter(.metric == "roc_auc"), 
       aes(x = base/idw, y = slope/idw, fill = mean)) +
  facet_wrap(~model_type) +
  scale_y_log10() + 
  geom_raster() +
  theme_bw() +
  ggtitle("ROC AUC by slope and base") +
  viridis::scale_fill_viridis()
```

## Additional Exploration - log scaling bathymetry

```{r}
idw <- 195 # Averaged from Sorochan et. al

threshold_method <- function(Bathy_depth, base, slope) {
  map_dbl(Bathy_depth - 300, max, 0) * slope + base
}

ae_test <- ae_dw |>
  mutate(patch = (dry_weight >= threshold_method(Bathy_depth, 40000*idw, 100*idw)) |>
           as.numeric() |> as.factor())
```

```{r}
recipe <- recipe(patch ~ Bathy_depth + SST + SSS + Sbtm + Tbtm + MLD + U + V + month, 
         data = ae_test) |>
    update_role(U, V, new_role = "ID") |>
    step_mutate(Vel = sqrt(U^2 + V^2), role = "predictor")

recipe_bathy <- recipe |>
  step_log(Bathy_depth, offset = 1, base = 10)

recipe_list <- list(recipe, recipe_bathy)
```

```{r} 
tuned <- boost_tree() |>
  set_mode("classification") |>
  set_engine("xgboost") |>
  set_args(trees = 1000,
           tree_depth = 6,
           learn_rate = 0.0745,
           min_n = 26,
           mtry = 5,
           sample_size = .597,
           loss_reduction = 0.00568)

model_list <- list(tuned)
```

**How do we define the base-slope values to explore?**

Base - Let's explore values 30,000 to 40,000, with slope 10 to 1000

```{r}
# Creating a workflow set
bathy_workflows <- workflow_set(recipe_list, model_list, 
                                cross = TRUE)
```

```{r eval = FALSE}
folds <- vfold_cv(ae_test, v = 4, repeats = 1, strata = "patch")

# resampling and collecting results
res_table <- bathy_workflows |>
  workflow_map(
    fn = "fit_resamples", 
               verbose = TRUE, 
               seed = 400, 
               resamples = folds, 
               metrics =  metric_set(roc_auc, accuracy))

res_table |> collect_metrics()

```
wflow_id            metric   mean       n standard error
no bathymetry log   accuracy 0.9243576	4	0.0007055766
''           	      roc_auc	 0.8855775	4	0.0043950262
bathymetry log      accuracy 0.9244096	4	0.0007051289
''                	roc_auc	 0.8855362	4 0.0043957763










